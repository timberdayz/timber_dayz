name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (e.g., v4.19.7, main-abc123)"
        required: true
        type: string
      confirm:
        description: 'Type "DEPLOY" to confirm production deployment'
        required: true
        type: string
  push:
    tags:
      - "v*"

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: ${{ github.repository }}/backend
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend

jobs:
  # 检查是否配置了必要的 secrets
  check-config:
    runs-on: ubuntu-latest
    outputs:
      can_deploy: ${{ steps.check.outputs.can_deploy }}
    steps:
      - name: Check deployment configuration
        id: check
        run: |
          if [ -z "${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}" ] || [ -z "${{ secrets.PRODUCTION_HOST }}" ]; then
            echo "Production deployment secrets not configured. Skipping deployment."
            echo "Required secrets: PRODUCTION_SSH_PRIVATE_KEY, PRODUCTION_HOST"
            echo "can_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "Production deployment secrets configured. Proceeding with deployment."
            echo "can_deploy=true" >> $GITHUB_OUTPUT
          fi

  deploy:
    runs-on: ubuntu-latest
    needs: check-config
    if: ${{ needs.check-config.outputs.can_deploy == 'true' }}
    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify deployment confirmation
        if: github.event_name == 'workflow_dispatch'
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "DEPLOY" ]; then
            echo "Deployment confirmation failed. Please type 'DEPLOY' to confirm."
            exit 1
          fi
          echo "Deployment confirmed"

      - name: Determine image tag
        id: image-tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref_type }}" == "tag" ]; then
            echo "tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          else
            echo "tag=latest" >> $GITHUB_OUTPUT
          fi
          echo "Deploying with tag: ${{ steps.image-tag.outputs.tag }}"

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}

      - name: Sync compose files to production server
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER || 'root' }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH || '/opt/xihong_erp' }}
        run: |
          # 检查服务器上是否有 git 仓库
          HAS_GIT=$(ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              ${PRODUCTION_USER}@${PRODUCTION_HOST} \
              "cd ${PRODUCTION_PATH} && [ -d .git ] && echo 'yes' || echo 'no'")

          if [ "${HAS_GIT}" = "yes" ]; then
            echo "[INFO] Git repository detected on server, attempting git pull..."
            
            # 通过 SSH 执行 git pull
            ssh -o StrictHostKeyChecking=no \
                -o ServerAliveInterval=30 \
                -o ServerAliveCountMax=10 \
                ${PRODUCTION_USER}@${PRODUCTION_HOST} << ENDSSH
              set -e
              cd ${PRODUCTION_PATH}
              
              # 检查是否有未提交的更改
              if [ -n "\$(git status --porcelain 2>/dev/null)" ]; then
                echo "[WARN] Uncommitted changes detected, stashing them..."
                git stash save "Auto-stash before deployment \$(date +%Y%m%d_%H%M%S)" || true
              fi
              
              # 尝试拉取最新代码（支持 main 或 master 分支）
              if git pull origin main 2>/dev/null || git pull origin master 2>/dev/null; then
                echo "[OK] Git pull successful, compose files synced"
              else
                echo "[WARN] Git pull failed, falling back to SCP method..."
                exit 1
              fi
            ENDSSH
            
            if [ $? -eq 0 ]; then
              echo "[OK] Compose files synced via git pull"
              exit 0
            fi
          else
            echo "[INFO] No git repository found on server, using SCP method..."
          fi

          # 方案2：使用 SCP 上传必要的 compose 文件
          echo "[INFO] Uploading compose files via SCP..."

          echo "[INFO] Uploading docker-compose.yml..."
          scp -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              docker-compose.yml ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/docker-compose.yml || {
            echo "[FAIL] Failed to upload docker-compose.yml"
            exit 1
          }

          if [ -f "docker-compose.prod.yml" ]; then
            echo "[INFO] Uploading docker-compose.prod.yml..."
            scp -o StrictHostKeyChecking=no \
                -o ServerAliveInterval=30 \
                -o ServerAliveCountMax=10 \
                docker-compose.prod.yml ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/docker-compose.prod.yml || {
              echo "[FAIL] Failed to upload docker-compose.prod.yml"
              exit 1
            }
          fi

          if [ -f "docker-compose.cloud.yml" ]; then
            echo "[INFO] Uploading docker-compose.cloud.yml..."
            scp -o StrictHostKeyChecking=no \
                -o ServerAliveInterval=30 \
                -o ServerAliveCountMax=10 \
                docker-compose.cloud.yml ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/docker-compose.cloud.yml || {
              echo "[WARN] Failed to upload docker-compose.cloud.yml (optional file)"
            }
          fi

          echo "[OK] Compose files synced successfully via SCP"

      - name: Backup current deployment
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER || 'root' }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH || '/opt/xihong_erp' }}
        run: |
          ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              ${PRODUCTION_USER}@${PRODUCTION_HOST} << ENDSSH
            set -e
            cd ${PRODUCTION_PATH}
            
            # 备份当前配置和状态
            BACKUP_DIR="backups/pre_deploy_\$(date +%Y%m%d_%H%M%S)"
            mkdir -p \${BACKUP_DIR}
            
            # 保存当前镜像标签（使用 production profile 确保包含所有服务）
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml --profile production config > \${BACKUP_DIR}/docker-compose.config.yaml 2>&1 || {
              echo "[WARN] Docker Compose config validation failed, but continuing backup..."
            }
            
            # 记录当前运行的容器
            docker ps --format "{{.Names}} {{.Image}}" > \${BACKUP_DIR}/running_containers.txt || true
            
            echo "[OK] Pre-deployment backup completed: \${BACKUP_DIR}"
          ENDSSH

      - name: Deploy to production server
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER || 'root' }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH || '/opt/xihong_erp' }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              ${PRODUCTION_USER}@${PRODUCTION_HOST} << ENDSSH
            set -e
            cd ${PRODUCTION_PATH}
            
            # 登录到容器仓库
            echo "[INFO] Logging in to container registry..."
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            echo "[OK] Successfully logged in to container registry"
            
            # 拉取指定版本的镜像（添加进度输出）
            echo "[INFO] Pulling images with tag: ${IMAGE_TAG}"
            echo "[INFO] Pulling backend image..."
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${IMAGE_TAG} || {
              echo "[FAIL] Failed to pull backend image with tag ${IMAGE_TAG}"
              exit 1
            }
            echo "[OK] Backend image pulled successfully"
            
            echo "[INFO] Pulling frontend image..."
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${IMAGE_TAG} || {
              echo "[FAIL] Failed to pull frontend image with tag ${IMAGE_TAG}"
              exit 1
            }
            echo "[OK] Frontend image pulled successfully"
            
            # 标记镜像为 latest（用于 docker-compose）
            echo "[INFO] Tagging images as latest..."
            docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${IMAGE_TAG} xihong_erp_backend:latest
            docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${IMAGE_TAG} xihong_erp_frontend:latest
            echo "[OK] Images tagged successfully"
            
            # ⭐ 清理可能占用端口80的旧容器
            echo "[INFO] Cleaning up old containers that might conflict with port 80..."
            # 停止并删除可能占用端口80的旧 frontend 容器
            docker stop xihong_erp_frontend 2>/dev/null || true
            docker rm xihong_erp_frontend 2>/dev/null || true
            # 检查是否有其他容器占用端口80
            PORT_80_CONTAINER=$(docker ps --format "{{.Names}}" --filter "publish=80" 2>/dev/null | head -1 || echo "")
            if [ -n "${PORT_80_CONTAINER}" ] && [ "${PORT_80_CONTAINER}" != "xihong_erp_nginx" ]; then
              echo "[WARN] Found container ${PORT_80_CONTAINER} using port 80, stopping it..."
              docker stop ${PORT_80_CONTAINER} 2>/dev/null || true
            fi
            echo "[OK] Cleanup completed"
            
            # 使用 docker-compose 部署（生产环境）
            export APP_ENV=production
            export COMPOSE_PROJECT_NAME=xihong_erp
            
            # ⭐ 说明：同步 compose 文件后，docker-compose up -d 会自动检测配置变化
            # 如果配置有变化（如端口、环境变量等），docker-compose 会自动重新创建容器
            # 因此不需要手动重新部署，工作流会自动完成部署
            
            # 创建临时 compose 文件，覆盖 build 为 image，并确保 frontend 不暴露端口
            echo "[INFO] Creating temporary docker-compose.deploy.yml..."
            cat > docker-compose.deploy.yml <<EOF
            services:
              backend:
                image: xihong_erp_backend:latest
              frontend:
                image: xihong_erp_frontend:latest
                # ⭐ 确保生产环境 frontend 不暴露端口（通过 nginx 反向代理访问）
                ports: []
            EOF
            echo "[OK] Temporary compose file created"
            
            # 检查是否存在云服务器优化配置（2核4G）
            if [ -f docker-compose.cloud.yml ]; then
              echo "[INFO] 使用云服务器优化配置（2核4G）"
              echo "[INFO] 应用最新的 compose 配置并启动/更新服务..."
              docker-compose -f docker-compose.yml -f docker-compose.prod.yml -f docker-compose.cloud.yml -f docker-compose.deploy.yml --profile production up -d
            else
              echo "[INFO] 使用标准生产配置"
              echo "[INFO] 应用最新的 compose 配置并启动/更新服务..."
              docker-compose -f docker-compose.yml -f docker-compose.prod.yml -f docker-compose.deploy.yml --profile production up -d
            fi
            echo "[OK] Docker Compose services started/updated"
            
            # 等待服务启动
            echo "[INFO] Waiting for services to start..."
            sleep 15
            echo "[INFO] Services should be starting now..."
            
            # 健康检查（通过容器网络检查，不依赖宿主机端口）
            echo "[INFO] Starting backend health check..."
            for i in {1..60}; do
              # ⭐ 修复：通过容器网络检查，不依赖宿主机端口映射
              if docker exec xihong_erp_backend curl -f http://localhost:8000/health > /dev/null 2>&1; then
                echo "[OK] Backend health check passed (container internal)"
                break
              fi
              if [ $i -eq 60 ]; then
                echo "[FAIL] Backend health check failed after 2 minutes"
                echo "[INFO] Checking backend logs..."
                docker-compose -f docker-compose.yml -f docker-compose.prod.yml -f docker-compose.deploy.yml logs backend 2>/dev/null || \
                docker-compose -f docker-compose.yml -f docker-compose.prod.yml logs backend
                exit 1
              fi
              if [ $((i % 5)) -eq 0 ]; then
                echo "[INFO] Waiting for backend... ($i/60)"
              fi
              sleep 2
            done
            
            # 验证前端（通过容器网络检查，不依赖宿主机端口）
            if docker ps | grep -q xihong_erp_frontend; then
              echo "[INFO] Checking frontend health (container internal)..."
              for i in {1..30}; do
                # ⭐ 修复：通过容器网络检查，不依赖宿主机端口映射
                if docker exec xihong_erp_frontend curl -f http://localhost:80 > /dev/null 2>&1; then
                  echo "[OK] Frontend health check passed (container internal)"
                  break
                fi
                if [ $i -eq 30 ]; then
                  echo "[WARN] Frontend health check failed (non-critical)"
                fi
                sleep 2
              done
            else
              echo "[INFO] Frontend container not found, skipping frontend health check"
            fi
            
            # 验证 Nginx（如果部署了 Nginx）
            if docker ps | grep -q xihong_erp_nginx; then
              echo "[INFO] Checking Nginx health..."
              for i in {1..30}; do
                if curl -f http://localhost/health > /dev/null 2>&1; then
                  echo "[OK] Nginx health check passed (port 80)"
                  break
                fi
                if [ $i -eq 30 ]; then
                  echo "[WARN] Nginx health check failed (non-critical)"
                fi
                sleep 2
              done
            else
              echo "[INFO] Nginx container not found, skipping Nginx health check"
            fi
            
            echo "[OK] Production deployment completed successfully"
            echo "Deployed image tag: ${IMAGE_TAG}"
            
            # 清理临时文件
            echo "[INFO] Cleaning up temporary files..."
            rm -f docker-compose.deploy.yml
            echo "[OK] Cleanup completed"
          ENDSSH

      - name: Health check verification
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
        run: |
          if [ -z "${PRODUCTION_URL}" ]; then
            echo "[WARN] PRODUCTION_URL not configured, skipping external health check"
            exit 0
          fi

          echo "[INFO] Checking production health at: ${PRODUCTION_URL}/health"

          # 增加重试机制和详细错误信息
          MAX_RETRIES=5
          RETRY_DELAY=10

          for i in $(seq 1 ${MAX_RETRIES}); do
            echo "[INFO] Health check attempt $i/${MAX_RETRIES}..."
            
            # 使用 curl 检查健康状态，增加超时和详细输出
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 --connect-timeout 10 ${PRODUCTION_URL}/health 2>/dev/null || echo "000")
            
            if [ "${HTTP_CODE}" = "200" ]; then
              echo "[OK] Production health check passed (HTTP ${HTTP_CODE})"
              exit 0
            else
              echo "[WARN] Health check failed (HTTP ${HTTP_CODE}), attempt $i/${MAX_RETRIES}"
              
              if [ $i -lt ${MAX_RETRIES} ]; then
                echo "[INFO] Retrying in ${RETRY_DELAY} seconds..."
                sleep ${RETRY_DELAY}
              else
                echo "[FAIL] Production health check failed after ${MAX_RETRIES} attempts"
                echo "[INFO] Final HTTP Status Code: ${HTTP_CODE}"
                echo "[INFO] Please check:"
                echo "  1. Is the production URL correct? (${PRODUCTION_URL})"
                echo "  2. Is the service running and accessible?"
                echo "  3. Is the /health endpoint responding?"
                echo "  4. Check server logs: docker logs xihong_erp_backend"
                
                # 尝试获取更多诊断信息
                echo "[INFO] Attempting to get more diagnostic information..."
                curl -v --max-time 10 ${PRODUCTION_URL}/health 2>&1 | head -20 || true
                
                exit 1
              fi
            fi
          done

      - name: Set up SSH for rollback
        if: failure()
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}

      - name: Rollback on failure
        if: failure()
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER || 'root' }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH || '/opt/xihong_erp' }}
        run: |
          ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              ${PRODUCTION_USER}@${PRODUCTION_HOST} << ENDSSH
            set -e
            cd ${PRODUCTION_PATH}
            
            echo "[WARNING] Deployment failed, attempting rollback..."
            
            # 查找上一个成功的部署备份
            LAST_BACKUP=\$(ls -td backups/pre_deploy_* 2>/dev/null | head -1)
            if [ -n "\$LAST_BACKUP" ]; then
              echo "Found backup: \$LAST_BACKUP"
              # 这里可以实现回滚逻辑（恢复配置、拉取上一个镜像等）
              echo "[WARNING] Manual rollback required. Check backup: \$LAST_BACKUP"
            else
              echo "[WARNING] No backup found for rollback"
            fi
          ENDSSH

      - name: Send deployment notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true # 如果 SLACK_WEBHOOK_URL 未配置会静默失败

  # 当部署被跳过时显示消息
  skip-notification:
    runs-on: ubuntu-latest
    needs: check-config
    if: ${{ needs.check-config.outputs.can_deploy == 'false' }}
    steps:
      - name: Deployment skipped
        run: |
          echo "========================================"
          echo "Deployment to production was SKIPPED"
          echo "========================================"
          echo ""
          echo "Required GitHub Secrets not configured:"
          echo "  - PRODUCTION_SSH_PRIVATE_KEY"
          echo "  - PRODUCTION_HOST"
          echo ""
          echo "To enable deployment, configure these secrets in:"
          echo "  Settings > Secrets and variables > Actions"
          echo "========================================"
