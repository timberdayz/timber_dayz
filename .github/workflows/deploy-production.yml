name: Deploy to Production

on:
  # [NOTE] 方案A：生产发布只通过 push tag(v*) 触发（同一条流水线内 build -> deploy）
  push:
    tags:
      - "v*"
  # [NOTE] 手动部署：用于回滚或重试（不会重新 build 镜像，只部署指定 tag）
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (e.g., v4.19.7)"
        required: true
        type: string
      confirm:
        description: 'Type "DEPLOY" to confirm production deployment'
        required: true
        type: string

# [NOTE] 并发控制：同一时间只允许一个生产部署在运行（避免带宽/资源冲突）
concurrency:
  group: deploy-production
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: ${{ github.repository }}/backend
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend

jobs:
  # 检查是否配置了必要的 secrets
  check-config:
    runs-on: ubuntu-latest
    outputs:
      can_deploy: ${{ steps.check.outputs.can_deploy }}
    steps:
      - name: Check deployment configuration
        id: check
        run: |
          if [ -z "${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}" ] || [ -z "${{ secrets.PRODUCTION_HOST }}" ]; then
            echo "Production deployment secrets not configured. Skipping deployment."
            echo "Required secrets: PRODUCTION_SSH_PRIVATE_KEY, PRODUCTION_HOST"
            echo "can_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "Production deployment secrets configured. Proceeding with deployment."
            echo "can_deploy=true" >> $GITHUB_OUTPUT
          fi

  validate:
    name: Validate Data Flow (Release Gate)
    runs-on: ubuntu-latest
    needs: check-config
    if: ${{ needs.check-config.outputs.can_deploy == 'true' && github.event_name == 'push' }}
    steps:
      - name: Checkout code (tag)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install -r requirements.txt

      - name: Create temp directory
        run: mkdir -p temp

      # [FIX] 计算本次发布改动的文件（只验证改动文件，避免历史遗留问题阻断新发布）
      - name: Get changed files since last tag
        id: changed-files
        run: |
          # 获取所有 tag，按版本号排序
          git fetch --tags --force

          # 获取当前 tag
          CURRENT_TAG="${{ github.ref_name }}"
          echo "[INFO] Current tag: ${CURRENT_TAG}"

          # 获取上一个 tag（按版本号排序，排除当前 tag，取最新的）
          ALL_TAGS=$(git tag --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$')
          PREV_TAG=$(echo "${ALL_TAGS}" | grep -v "^${CURRENT_TAG}$" | head -n 1)

          if [ -z "${PREV_TAG}" ]; then
            echo "[INFO] 未找到上一个 tag，将验证所有文件（首次发布或只有一个 tag）"
            echo "has_prev_tag=false" >> $GITHUB_OUTPUT
            echo "prev_tag=" >> $GITHUB_OUTPUT
            echo "changed_count=0" >> $GITHUB_OUTPUT
          else
            echo "[INFO] 上一个 tag: ${PREV_TAG}"
            echo "has_prev_tag=true" >> $GITHUB_OUTPUT
            echo "prev_tag=${PREV_TAG}" >> $GITHUB_OUTPUT
            
            # 计算改动的文件（相对于项目根目录）
            # 注意：HEAD 指向当前 checkout 的 tag commit
            git diff --name-only ${PREV_TAG}..HEAD > temp/changed_files.txt || true
            
            # 显示改动的文件数量
            CHANGED_COUNT=$(wc -l < temp/changed_files.txt | tr -d ' ' || echo "0")
            echo "[INFO] 发现 ${CHANGED_COUNT} 个改动文件（从 ${PREV_TAG} 到 ${CURRENT_TAG}）"
            echo "changed_count=${CHANGED_COUNT}" >> $GITHUB_OUTPUT
            
            # 显示前10个改动的文件（用于调试）
            if [ "${CHANGED_COUNT}" -gt 0 ]; then
              echo "[INFO] 改动的文件（前10个）:"
              head -10 temp/changed_files.txt | sed 's/^/  - /'
              
              # 显示改动的 router 文件数量
              ROUTER_COUNT=$(grep -c "^backend/routers/.*\.py$" temp/changed_files.txt || echo "0")
              echo "[INFO] 其中 router 文件: ${ROUTER_COUNT} 个"
            else
              echo "[INFO] 没有发现改动文件（可能是 tag 指向同一个 commit）"
            fi
          fi

      # [NOTE] 发布门禁：tag 发布必须通过这些检查；失败会阻断 build 和 deploy
      # [FIX] 只验证改动的 router 文件，避免历史遗留问题阻断新发布
      - name: Validate API Contracts (Release Gate)
        run: |
          if [ "${{ steps.changed-files.outputs.has_prev_tag }}" == "true" ] && [ -f "temp/changed_files.txt" ]; then
            echo "[INFO] 只验证改动的 router 文件..."
            python scripts/validate_api_contracts.py --changed-files temp/changed_files.txt
          else
            echo "[INFO] 未找到改动文件列表，验证所有文件..."
            python scripts/validate_api_contracts.py
          fi

      - name: Validate Frontend API Methods (Release Gate)
        run: |
          if [ "${{ steps.changed-files.outputs.has_prev_tag }}" == "true" ] && [ -f "temp/changed_files.txt" ]; then
            echo "[INFO] 只验证改动的前端文件..."
            python scripts/validate_frontend_api_methods.py --changed-files temp/changed_files.txt
          else
            echo "[INFO] 未找到改动文件列表，验证所有前端文件..."
            python scripts/validate_frontend_api_methods.py
          fi

      - name: Validate Database Fields (Release Gate)
        run: python scripts/validate_database_fields.py

  build-and-push:
    name: Build and Push Images (Release Tag)
    runs-on: ubuntu-latest
    needs: validate
    if: ${{ github.event_name == 'push' }}
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code (tag)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            # [FIX] 同时推送带 v 前缀的 tag（v4.20.5 / 4.20.5），避免部署端找不到 manifest
            type=semver,pattern=v{{version}}
            type=semver,pattern=v{{major}}.{{minor}}
            # [FIX] 固定 sha tag 规则，避免生成非法 tag
            type=sha,format=short,prefix=sha-

      - name: Extract metadata (tags, labels) for frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            # [FIX] 同时推送带 v 前缀的 tag（v4.20.5 / 4.20.5）
            type=semver,pattern=v{{version}}
            type=semver,pattern=v{{major}}.{{minor}}
            # [FIX] 固定 sha tag 规则，避免生成非法 tag
            type=sha,format=short,prefix=sha-

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.backend
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            PYTHON_VERSION=3.11

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.frontend
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          target: production
          build-args: |
            NODE_VERSION=18
            VITE_API_URL=${{ secrets.VITE_API_URL || 'http://localhost:8001' }}

  deploy-tag:
    name: Deploy to Production (Tag Release)
    runs-on: ubuntu-latest
    needs: [check-config, validate, build-and-push]
    if: ${{ needs.check-config.outputs.can_deploy == 'true' && github.event_name == 'push' }}
    environment:
      name: production

    steps:
      - name: Checkout code (tag)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Determine deploy tag (from ref)
        id: image-tag
        run: |
          echo "tag=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
          echo "Deploying with tag: ${GITHUB_REF_NAME}"

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}

      - name: Sync compose files to production server
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER || 'root' }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH || '/opt/xihong_erp' }}
        run: |
          # [NOTE] 方案A1：直接使用 SCP 上传 compose 文件（移除 git pull，更简单、更稳定）
          # compose 文件很小，对 5MB 带宽影响很小，不需要配置服务器 git 凭据
          echo "[INFO] Uploading compose files via SCP..."

          # 1. 上传 docker-compose.yml（必需）
          echo "[INFO] Uploading docker-compose.yml..."
          scp -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              docker-compose.yml ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/docker-compose.yml || {
            echo "[FAIL] Failed to upload docker-compose.yml"
            exit 1
          }
          echo "[OK] docker-compose.yml uploaded successfully"

          # 2. 上传 docker-compose.prod.yml（必需，如果存在）
          if [ -f "docker-compose.prod.yml" ]; then
            echo "[INFO] Uploading docker-compose.prod.yml..."
            scp -o StrictHostKeyChecking=no \
                -o ServerAliveInterval=30 \
                -o ServerAliveCountMax=10 \
                docker-compose.prod.yml ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/docker-compose.prod.yml || {
              echo "[FAIL] Failed to upload docker-compose.prod.yml"
              exit 1
            }
            echo "[OK] docker-compose.prod.yml uploaded successfully"
          else
            echo "[WARN] docker-compose.prod.yml not found, skipping..."
          fi

          # 3. 上传 docker-compose.cloud.yml（可选，如果存在）
          if [ -f "docker-compose.cloud.yml" ]; then
            echo "[INFO] Uploading docker-compose.cloud.yml..."
            if scp -o StrictHostKeyChecking=no \
                -o ServerAliveInterval=30 \
                -o ServerAliveCountMax=10 \
                docker-compose.cloud.yml ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/docker-compose.cloud.yml; then
              echo "[OK] docker-compose.cloud.yml uploaded successfully"
            else
              echo "[WARN] Failed to upload docker-compose.cloud.yml (optional file, continuing...)"
            fi
          else
            echo "[INFO] docker-compose.cloud.yml not found, skipping (optional file)..."
          fi

          # 4. 上传 docker-compose.metabase.yml（生产必需组件，如果存在）
          if [ -f "docker-compose.metabase.yml" ]; then
            echo "[INFO] Uploading docker-compose.metabase.yml..."
            scp -o StrictHostKeyChecking=no \
                -o ServerAliveInterval=30 \
                -o ServerAliveCountMax=10 \
                docker-compose.metabase.yml ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/docker-compose.metabase.yml || {
              echo "[FAIL] Failed to upload docker-compose.metabase.yml (required for production)"
              exit 1
            }
            echo "[OK] docker-compose.metabase.yml uploaded successfully"
          else
            echo "[WARN] docker-compose.metabase.yml not found (required for production, deployment may fail if Metabase is not configured)"
          fi

          # 5. 上传远程部署脚本（方案A：避免在 workflow 中维护超长 bash -c 片段）
          echo "[INFO] Uploading deploy_remote_production.sh..."
          scp -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              scripts/deploy_remote_production.sh ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/deploy_remote_production.sh || {
            echo "[FAIL] Failed to upload deploy_remote_production.sh"
            exit 1
          }
          echo "[OK] deploy_remote_production.sh uploaded successfully"

          echo "[OK] All compose files synced successfully via SCP"

      - name: Backup current deployment
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER || 'root' }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH || '/opt/xihong_erp' }}
        run: |
          # [FIX] 使用 bash -c 远程执行，避免 heredoc 语法问题
          ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              ${PRODUCTION_USER}@${PRODUCTION_HOST} \
              "bash -c 'set -e; \
              cd \"${PRODUCTION_PATH}\"; \
              BACKUP_DIR=\"backups/pre_deploy_\$(date +%Y%m%d_%H%M%S)\"; \
              mkdir -p \"\${BACKUP_DIR}\"; \
              docker-compose -f docker-compose.yml -f docker-compose.prod.yml --profile production config > \"\${BACKUP_DIR}/docker-compose.config.yaml\" 2>&1 || echo \"[WARN] Docker Compose config validation failed, but continuing backup...\"; \
              docker ps --format \"{{.Names}} {{.Image}}\" > \"\${BACKUP_DIR}/running_containers.txt\" || true; \
              echo \"[OK] Pre-deployment backup completed: \${BACKUP_DIR}\"'"

      - name: Deploy to production server
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER || 'root' }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH || '/opt/xihong_erp' }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          # [FIX] 方案A：部署逻辑统一封装到脚本，避免超长 bash -c 片段导致引号/换行问题
          # 通过 stdin 传递 token，避免把 token 写进远程命令行参数
          printf '%s\n' "${{ secrets.GITHUB_TOKEN }}" | ssh -o StrictHostKeyChecking=no \
            -o ServerAliveInterval=30 \
            -o ServerAliveCountMax=10 \
            ${PRODUCTION_USER}@${PRODUCTION_HOST} \
            "bash -c 'set -e; cd \"${PRODUCTION_PATH}\"; \
              read -r GHCR_TOKEN; export GHCR_TOKEN; \
              chmod +x ./deploy_remote_production.sh; \
              export GHCR_REGISTRY=\"${{ env.REGISTRY }}\"; \
              export GHCR_USER=\"${{ github.actor }}\"; \
              export IMAGE_NAME_BACKEND=\"${{ env.IMAGE_NAME_BACKEND }}\"; \
              export IMAGE_NAME_FRONTEND=\"${{ env.IMAGE_NAME_FRONTEND }}\"; \
              export IMAGE_TAG=\"${IMAGE_TAG}\"; \
              bash ./deploy_remote_production.sh'"

  deploy-manual:
    name: Deploy to Production (Manual)
    runs-on: ubuntu-latest
    needs: check-config
    if: ${{ needs.check-config.outputs.can_deploy == 'true' && github.event_name == 'workflow_dispatch' }}
    environment:
      name: production
    steps:
      - name: Checkout code (main)
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Verify deployment confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "DEPLOY" ]; then
            echo "Deployment confirmation failed. Please type 'DEPLOY' to confirm."
            exit 1
          fi
          echo "Deployment confirmed"

      - name: Determine deploy tag (manual input)
        id: image-tag
        run: |
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          echo "Deploying with tag: ${{ github.event.inputs.image_tag }}"

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}

      - name: Sync compose files to production server
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER || 'root' }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH || '/opt/xihong_erp' }}
        run: |
          echo "[INFO] Uploading compose files via SCP..."
          scp -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              docker-compose.yml ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/docker-compose.yml || {
            echo "[FAIL] Failed to upload docker-compose.yml"
            exit 1
          }
          if [ -f "docker-compose.prod.yml" ]; then
            scp -o StrictHostKeyChecking=no \
                -o ServerAliveInterval=30 \
                -o ServerAliveCountMax=10 \
                docker-compose.prod.yml ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/docker-compose.prod.yml || {
              echo "[FAIL] Failed to upload docker-compose.prod.yml"
              exit 1
            }
          fi
          if [ -f "docker-compose.cloud.yml" ]; then
            scp -o StrictHostKeyChecking=no \
                -o ServerAliveInterval=30 \
                -o ServerAliveCountMax=10 \
                docker-compose.cloud.yml ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/docker-compose.cloud.yml || {
              echo "[WARN] Failed to upload docker-compose.cloud.yml (optional file, continuing...)"
            }
          fi
          if [ -f "docker-compose.metabase.yml" ]; then
            scp -o StrictHostKeyChecking=no \
                -o ServerAliveInterval=30 \
                -o ServerAliveCountMax=10 \
                docker-compose.metabase.yml ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/docker-compose.metabase.yml || {
              echo "[FAIL] Failed to upload docker-compose.metabase.yml (required for production)"
              exit 1
            }
          fi

          # 同步远程部署脚本（方案A：deploy-tag 与 deploy-manual 共用同一套部署逻辑）
          scp -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              scripts/deploy_remote_production.sh ${PRODUCTION_USER}@${PRODUCTION_HOST}:${PRODUCTION_PATH}/deploy_remote_production.sh || {
            echo "[FAIL] Failed to upload deploy_remote_production.sh"
            exit 1
          }
          echo "[OK] All compose files synced successfully via SCP"

      - name: Backup current deployment
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER || 'root' }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH || '/opt/xihong_erp' }}
        run: |
          ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              ${PRODUCTION_USER}@${PRODUCTION_HOST} \
              "bash -c 'set -e; \
              cd \"${PRODUCTION_PATH}\"; \
              BACKUP_DIR=\"backups/pre_deploy_$(date +%Y%m%d_%H%M%S)\"; \
              mkdir -p \"${BACKUP_DIR}\"; \
              docker-compose -f docker-compose.yml -f docker-compose.prod.yml --profile production config > \"${BACKUP_DIR}/docker-compose.config.yaml\" 2>&1 || echo \"[WARN] Docker Compose config validation failed, but continuing backup...\"; \
              docker ps --format \"{{.Names}} {{.Image}}\" > \"${BACKUP_DIR}/running_containers.txt\" || true; \
              echo \"[OK] Pre-deployment backup completed: ${BACKUP_DIR}\"'"

      - name: Deploy to production server
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER || 'root' }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH || '/opt/xihong_erp' }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          # [FIX] 方案A：与 deploy-tag 使用同一脚本，确保手动部署/回滚路径与自动发布一致
          printf '%s\n' "${{ secrets.GITHUB_TOKEN }}" | ssh -o StrictHostKeyChecking=no \
            -o ServerAliveInterval=30 \
            -o ServerAliveCountMax=10 \
            ${PRODUCTION_USER}@${PRODUCTION_HOST} \
            "bash -c 'set -e; cd \"${PRODUCTION_PATH}\"; \
              read -r GHCR_TOKEN; export GHCR_TOKEN; \
              chmod +x ./deploy_remote_production.sh; \
              export GHCR_REGISTRY=\"${{ env.REGISTRY }}\"; \
              export GHCR_USER=\"${{ github.actor }}\"; \
              export IMAGE_NAME_BACKEND=\"${{ env.IMAGE_NAME_BACKEND }}\"; \
              export IMAGE_NAME_FRONTEND=\"${{ env.IMAGE_NAME_FRONTEND }}\"; \
              export IMAGE_TAG=\"${IMAGE_TAG}\"; \
              bash ./deploy_remote_production.sh'"

      - name: Health check verification
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
        run: |
          if [ -z "${PRODUCTION_URL}" ]; then
            echo "[WARN] PRODUCTION_URL not configured, skipping external health check"
            exit 0
          fi

          # [FIX] 域名备案期间，如果配置了 HTTPS 但 SSL 证书未配置，自动降级到 HTTP
          HEALTH_CHECK_URL="${PRODUCTION_URL}"
          if [[ "${PRODUCTION_URL}" == https://* ]]; then
            echo "[INFO] PRODUCTION_URL is HTTPS, attempting HTTPS health check first..."
            
            # 先尝试 HTTPS（如果 SSL 已配置）
            HTTPS_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 --connect-timeout 5 ${PRODUCTION_URL}/health 2>/dev/null || echo "000")
            
            if [ "${HTTPS_CODE}" = "200" ]; then
              echo "[OK] HTTPS health check passed, using HTTPS"
            else
              # HTTPS 失败，降级到 HTTP（域名备案期间，SSL 证书可能未配置）
              HTTP_URL="${PRODUCTION_URL/https:\/\//http:\/\/}"
              echo "[INFO] HTTPS health check failed (HTTP ${HTTPS_CODE}), domain may be in ICP filing process"
              echo "[INFO] Falling back to HTTP for health check: ${HTTP_URL}/health"
              echo "[INFO] Note: After ICP filing is completed and SSL certificate is configured, HTTPS will be used"
              HEALTH_CHECK_URL="${HTTP_URL}"
            fi
          fi

          echo "[INFO] Checking production health at: ${HEALTH_CHECK_URL}/health"

          # 增加重试机制和详细错误信息
          MAX_RETRIES=5
          RETRY_DELAY=10

          for i in $(seq 1 ${MAX_RETRIES}); do
            echo "[INFO] Health check attempt $i/${MAX_RETRIES}..."
            
            # 使用 curl 检查健康状态，增加超时和详细输出
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 --connect-timeout 10 ${HEALTH_CHECK_URL}/health 2>/dev/null || echo "000")
            
            if [ "${HTTP_CODE}" = "200" ]; then
              echo "[OK] Production health check passed (HTTP ${HTTP_CODE})"
              if [[ "${HEALTH_CHECK_URL}" == http://* ]] && [[ "${PRODUCTION_URL}" == https://* ]]; then
                echo "[INFO] Using HTTP during ICP filing period. HTTPS will be enabled after SSL certificate is configured."
              fi
              exit 0
            else
              echo "[WARN] Health check failed (HTTP ${HTTP_CODE}), attempt $i/${MAX_RETRIES}"
              
              if [ $i -lt ${MAX_RETRIES} ]; then
                echo "[INFO] Retrying in ${RETRY_DELAY} seconds..."
                sleep ${RETRY_DELAY}
              else
                echo "[FAIL] Production health check failed after ${MAX_RETRIES} attempts"
                echo "[INFO] Final HTTP Status Code: ${HTTP_CODE}"
                echo "[INFO] Health Check URL used: ${HEALTH_CHECK_URL}/health"
                echo "[INFO] Original PRODUCTION_URL: ${PRODUCTION_URL}"
                echo "[INFO] Please check:"
                echo "  1. Is the production URL correct? (${PRODUCTION_URL})"
                echo "  2. Is the service running and accessible?"
                echo "  3. Is the /health endpoint responding?"
                echo "  4. Check server logs: docker logs xihong_erp_backend"
                echo "  5. If domain is in ICP filing process, ensure DNS points to server IP"
                echo "  6. Check server firewall/security group allows port 80 (HTTP)"
                
                # 尝试获取更多诊断信息
                echo "[INFO] Attempting to get more diagnostic information..."
                curl -v --max-time 10 ${HEALTH_CHECK_URL}/health 2>&1 | head -20 || true
                
                exit 1
              fi
            fi
          done

      - name: Set up SSH for rollback
        if: failure()
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}

      - name: Rollback on failure
        if: failure()
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER || 'root' }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH || '/opt/xihong_erp' }}
        run: |
          # [FIX] 避免 heredoc 语法问题，使用 bash -c 执行远程命令
          ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              ${PRODUCTION_USER}@${PRODUCTION_HOST} \
              "bash -c '
            set -e
              cd \"${PRODUCTION_PATH}\"
            
              echo \"[WARNING] Deployment failed, attempting rollback...\"
            
            # 查找上一个成功的部署备份
              LAST_BACKUP=\$(ls -td backups/pre_deploy_* 2>/dev/null | head -1)
              if [ -n \"\${LAST_BACKUP}\" ]; then
                echo \"Found backup: \${LAST_BACKUP}\"
              # 这里可以实现回滚逻辑（恢复配置、拉取上一个镜像等）
                echo \"[WARNING] Manual rollback required. Check backup: \${LAST_BACKUP}\"
            else
                echo \"[WARNING] No backup found for rollback\"
            fi
              '"

      - name: Send deployment notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true # 如果 SLACK_WEBHOOK_URL 未配置会静默失败

  # 当部署被跳过时显示消息
  skip-notification:
    runs-on: ubuntu-latest
    needs: check-config
    if: ${{ needs.check-config.outputs.can_deploy == 'false' }}
    steps:
      - name: Deployment skipped
        run: |
          echo "========================================"
          echo "Deployment to production was SKIPPED"
          echo "========================================"
          echo ""
          echo "Required GitHub Secrets not configured:"
          echo "  - PRODUCTION_SSH_PRIVATE_KEY"
          echo "  - PRODUCTION_HOST"
          echo ""
          echo "To enable deployment, configure these secrets in:"
          echo "  Settings > Secrets and variables > Actions"
          echo "========================================"
