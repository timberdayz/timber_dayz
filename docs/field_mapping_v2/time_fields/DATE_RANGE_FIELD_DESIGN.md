# 时间范围字段设计方案

## 设计目标

- ✅ 统一处理：将所有时间范围格式统一为标准的 `start_time` + `end_time` 两个字段
- ✅ 智能识别：自动识别时间范围格式（如 `2025-08-25 17:01~2025-08-26 11:02`）
- ✅ 查询友好：分开存储便于索引和查询（如"查询某个时间段内的数据"）
- ✅ 兼容现有：沿用 `CatalogFile.date_from/date_to` 的设计模式

## 设计方案

### 方案一：智能拆分（推荐）⭐⭐⭐

**核心思路**：将时间范围字段自动拆分为两个独立的datetime字段

#### 1. 标准字段定义

在辞典中添加两个通用字段：

| 字段代码 | 中文名称 | 数据类型 | 说明 |
|:---|:---|:---|:---|
| `start_time` | 开始时间 | datetime | 时间范围的起始时间 |
| `end_time` | 结束时间 | datetime | 时间范围的结束时间 |

#### 2. 自动识别逻辑

```python
# 在 type_detector.py 中新增
def detect_date_range_format(value: str) -> Optional[tuple]:
    """
    检测是否为时间范围格式，返回(start_time, end_time)
    
    支持的格式：
    - 2025-08-25 17:01~2025-08-26 11:02
    - 2025-08-25~2025-08-26
    - 25/08/2025 - 26/08/2025
    - 2025-08-25 17:01 至 2025-08-26 11:02
    """
    # 识别时间范围分隔符：~、-、至、to、～
    patterns = [
        r'(\d{4}[-/]\d{1,2}[-/]\d{1,2}\s*\d{1,2}:\d{2}(?::\d{2})?)\s*[~\-至to～]\s*(\d{4}[-/]\d{1,2}[-/]\d{1,2}\s*\d{1,2}:\d{2}(?::\d{2})?)',
        r'(\d{4}[-/]\d{1,2}[-/]\d{1,2})\s*[~\-至to～]\s*(\d{4}[-/]\d{1,2}[-/]\d{1,2})',
    ]
    # ... 解析逻辑
    return (start_time, end_time)
```

#### 3. 映射流程

```
原始字段: "日期期间" = "2025-08-25 17:01~2025-08-26 11:02"
         ↓
自动识别: 检测到时间范围格式
         ↓
智能映射: 
  - "日期期间" → start_time (2025-08-25 17:01)
  - "日期期间" → end_time (2025-08-26 11:02)
         ↓
用户确认: 系统提示"检测到时间范围，将拆分为开始时间和结束时间"
         ↓
入库: 两个独立的datetime字段
```

#### 4. 数据库存储

**事实表设计**（以 `FactOrder` 为例）：

```python
# 如果需要时间范围，添加两个字段
start_time = Column(DateTime, nullable=True)  # 开始时间
end_time = Column(DateTime, nullable=True)    # 结束时间

# 索引优化
Index("ix_order_time_range", "start_time", "end_time"),
```

**查询示例**：

```sql
-- 查询某个时间段内的订单
SELECT * FROM fact_orders 
WHERE start_time <= '2025-08-26 11:02' 
  AND end_time >= '2025-08-25 17:01';

-- 查询跨时间段的数据
SELECT * FROM fact_orders 
WHERE start_time >= '2025-08-25' 
  AND end_time <= '2025-08-26';
```

### 方案二：PostgreSQL原生范围类型（高级）

如果使用PostgreSQL，可以考虑使用原生范围类型：

```sql
-- 使用tsrange类型
time_range = Column(TSRANGE, nullable=True)  -- PostgreSQL专用

-- 查询示例
SELECT * FROM fact_orders 
WHERE time_range && '[2025-08-25 17:01, 2025-08-26 11:02]'::tsrange;
```

**优点**：
- 数据库原生支持，查询高效
- 自动验证范围有效性（start < end）

**缺点**：
- 只支持PostgreSQL，迁移性差
- SQLAlchemy支持有限

### 方案三：JSONB存储（灵活但性能较差）

```python
# 存储在attributes JSONB中
attributes = {
    "date_range": {
        "start": "2025-08-25 17:01",
        "end": "2025-08-26 11:02"
    }
}
```

**优点**：
- 灵活，不影响核心字段
- 可以存储额外信息（如时区）

**缺点**：
- 查询性能较差
- 无法直接使用索引

## 推荐方案：方案一（智能拆分）

### 实施步骤

1. **更新辞典**
   - 添加 `start_time` 和 `end_time` 两个标准字段
   - 设置适当的同义词（如"开始时间"、"结束时间"、"起始时间"、"终止时间"）

2. **增强类型检测器**
   - 在 `type_detector.py` 中添加 `detect_date_range_format` 函数
   - 识别常见的时间范围格式

3. **更新映射逻辑**
   - 当检测到时间范围格式时，自动映射到 `start_time` 和 `end_time`
   - 在前端提示用户"时间范围已自动拆分为开始时间和结束时间"

4. **更新数据标准化器**
   - 在 `data_standardizer.py` 中添加时间范围解析逻辑
   - 自动拆分并标准化为两个datetime对象

5. **更新事实表（按需）**
   - 如果某个数据域需要时间范围，添加 `start_time` 和 `end_time` 字段
   - 或者存储在 `attributes` JSONB中（如果使用频率不高）

### 用户界面体验

**映射界面**：
```
原始字段: "日期期间"
示例值: "2025-08-25 17:01~2025-08-26 11:02"
         ↓
系统提示: "检测到时间范围格式，将自动拆分为：
         - 开始时间: 2025-08-25 17:01
         - 结束时间: 2025-08-26 11:02"
         ↓
映射结果:
  "日期期间" → start_time (自动)
  "日期期间" → end_time (自动)
```

## 实施建议

### 阶段一：核心功能（立即实施）

1. ✅ 在辞典中添加 `start_time` 和 `end_time` 字段
2. ✅ 实现时间范围识别函数
3. ✅ 更新映射逻辑，自动拆分时间范围

### 阶段二：优化（后续优化）

1. 根据实际使用情况决定是否在事实表中添加专门的 `start_time`/`end_time` 列
2. 如果使用频率不高，继续存储在 `attributes` JSONB中
3. 如果使用频率高，考虑使用PostgreSQL的tsrange类型

## 优势总结

1. **统一性**：沿用 `CatalogFile.date_from/date_to` 的设计模式，保持系统一致性
2. **查询友好**：分开存储便于索引和复杂查询
3. **智能识别**：自动识别常见时间范围格式，用户无需手动拆分
4. **向后兼容**：现有数据不受影响，新数据自动处理
5. **灵活性**：如果某个数据域不需要时间范围，可以不添加这两个字段

