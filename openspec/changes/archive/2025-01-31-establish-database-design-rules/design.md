# 技术设计：建立数据库设计规则规范

## Context

经过数据库设计规则审查，我们发现数据库设计缺少明确的规则规范，导致后续开发中出现不一致和问题。我们需要从源头开始梳理后端的运作方式，建立明确的数据库设计规则规范。

## Goals

- **正式化数据库设计规范**：将现有的数据库设计规范草案正式化，补充完整的需求和场景定义
- **明确后端运作规则**：定义数据入库流程规则、字段映射规则、事实表和物化视图设计规则
- **建立规则执行机制**：创建规则验证工具、规则文档、规则审查流程
- **更新现有代码以符合规范**：审查现有代码，修复不符合规范的问题

## Non-Goals

- 不修改现有数据库结构（除非发现根本性问题）
- 不改变现有API接口（保持向后兼容）
- 不引入新的技术依赖

## Decisions

### 决策1：正式化OpenSpec规范文档

**决策**：将现有的数据库设计规范草案（`openspec/specs/database-design/spec.md`）正式化，补充完整的需求和场景定义。

**理由**：
- OpenSpec格式的规范更加正式和可执行
- 需求和场景定义可以指导开发人员正确使用规则
- 可以与代码验证工具集成

**替代方案**：
- 只更新技术规范文档（不够正式，难以执行）

### 决策2：经营数据和运营数据分离存储

**决策**：将经营数据（miaoshou ERP）和运营数据（shopee/tiktok）分开存储，使用不同的事实表和主键设计规则。

**理由**：
- 经营数据和运营数据的业务特征不同（经营数据以SKU为核心，运营数据以shop_id为核心）
- 分离存储可以更好地匹配源数据特征，提高数据同步可靠性
- 便于后续的数据分析和报表生成

**主键设计规则**：
- **经营数据**：以SKU为核心标识，使用自增ID作为主键，业务唯一索引包含platform_sku（如(platform_code, shop_id, platform_sku, metric_date, data_domain)）
  - 原因：自增ID便于外键引用和性能优化，业务唯一性通过唯一索引保证
  - 店铺别名通过AccountAlias表映射到标准shop_id
  - 库存快照数据允许shop_id为NULL（仓库级数据）
- **运营数据**：以shop_id为核心标识，使用自增ID作为主键，业务唯一索引包含shop_id（如(platform_code, shop_id, metric_date, metric_type, data_domain)）
  - 原因：自增ID便于外键引用和性能优化，业务唯一性通过唯一索引保证
  - shop_id从文件元数据（.meta.json）中提取
  - 平台级数据使用account作为替代标识

**店铺别名映射**：
- miaoshou ERP的店铺信息是别名（如"新加坡1店"），需要通过AccountAlias表映射到标准shop_id
- shopee/tiktok的shop_id从文件元数据（.meta.json）中提取

**替代方案**：
- 统一使用shop_id作为主键（不符合经营数据的业务特征）
- 统一使用SKU作为主键（不符合运营数据的业务特征）

### 决策3：物化视图数据域集中设计

**决策**：一个数据域的所有信息集中在一个物化视图上，确保前端可以从物化视图中一次性获取数据域的所有信息。

**理由**：
- 减少前端查询次数，提高查询效率
- 便于用户审查数据，数据域信息一目了然
- 符合企业级ERP系统的数据组织方式

**设计原则**：
- **主视图**：每个数据域（如products、orders、traffic、inventory等）对应一个主视图，包含该数据域的所有核心字段
  - products域主视图：mv_product_management（包含SKU、名称、价格、库存、销量、销售额、流量、转化率等）
  - orders域主视图：mv_order_summary（包含订单ID、日期、金额、状态、商品、买家等）
  - traffic域主视图：mv_traffic_summary（包含shop_id、日期、UV、PV、转化率、服务指标等）
  - inventory域主视图：mv_inventory_summary（包含SKU、库存数量、可用库存、在途库存等）
- **辅助视图**：用于特定分析场景，依赖主视图或基础数据
  - 销售趋势分析：mv_product_sales_trend（依赖mv_product_management）
  - TopN排行：mv_top_products（依赖mv_product_management）
  - 日/周/月销售汇总：mv_daily_sales, mv_weekly_sales, mv_monthly_sales（依赖订单数据）
- **视图依赖关系**：明确主视图和辅助视图的依赖关系，确保刷新顺序正确（先刷新主视图，再刷新辅助视图）
- **前端查询策略**：前端优先查询主视图获取数据域的所有核心信息，辅助视图仅用于特定分析场景

**替代方案**：
- 一个物化视图包含多个数据域的信息（会导致视图过于复杂，难以维护）
- 一个数据域分散在多个物化视图中（会导致前端需要多次查询，降低效率）

### 决策7：产品ID原子级设计规则

**决策**：在经营数据事实表中添加product_id冗余字段，创建以product_id为原子级的销售明细物化视图。

**理由**：
- 产品ID（SN）是每个产品实例的唯一标识，类似华为ISRP系统的设计
- 支持以产品ID为原子级查询销售明细，满足业务需求（如查询某个具体产品的销售情况）
- 保持SKU为主键设计（符合经营数据规则），同时支持产品ID查询（冗余字段设计）
- 物化视图以product_id为原子级，整合所有销售信息，类似华为ISRP的销售明细表

**设计原则**：
- **冗余字段设计**：在FactOrderItem表中添加product_id字段（冗余字段，便于直接查询）
  - 保持现有主键不变（platform_code, shop_id, order_id, platform_sku）
  - product_id通过BridgeProductKeys关联获取
  - 添加索引以支持高效查询
- **销售明细物化视图**：创建mv_sales_detail_by_product视图，以product_id为原子级
  - 每行代表一个产品实例的销售明细
  - 包含产品信息（product_id、SKU、名称、规格等）
  - 包含订单信息（订单ID、日期、状态、买家等）
  - 包含价格信息（单价、行金额、成本、利润等）
  - 包含店铺和平台信息
  - 类似华为ISRP系统的销售明细表结构
- **数据入库流程**：在订单明细入库时自动关联product_id
  - 通过BridgeProductKeys查找product_id
  - 如果找不到，product_id为NULL（允许，但应记录警告）
  - 支持后续数据修复和关联

**产品ID与SKU的关系**：
- **产品ID（product_id/SN）**：每个产品实例的唯一标识（类似身份证），用于查询具体产品的销售情况
- **SKU（platform_sku）**：产品类型的标识（类似人种），用于查询整个产品类型的销售情况
- **关系**：一个SKU可以对应多个product_id（同一产品类型的不同实例）

**替代方案**：
- 不使用冗余字段，每次都通过BridgeProductKeys关联（性能较差，查询复杂）
- 以product_id为主键（不符合经营数据以SKU为核心的规则）

### 决策4：创建运营数据事实表

**决策**：为运营数据创建专门的事实表（FactTraffic、FactService、FactAnalytics），与经营数据表分离。

**理由**：
- 运营数据和经营数据的业务特征不同，分离存储更清晰
- 主键设计规则不同（运营数据以shop_id为核心，经营数据以SKU为核心）
- 便于后续的数据分析和报表生成
- 提高查询性能（索引更精准）

**表结构设计**：
- **FactTraffic**：流量数据表（shop_id为核心，包含UV、PV、转化率等）
- **FactService**：服务数据表（shop_id为核心，包含服务人数、响应时间、满意度等）
- **FactAnalytics**：分析数据表（shop_id为核心，包含各种分析指标）

**替代方案**：
- 使用现有的FactProductMetric表（不符合运营数据的业务特征，主键设计不合理）

### 决策5：建立规则执行机制

**决策**：创建规则验证工具、规则文档、规则审查流程。

**理由**：
- 规则需要执行机制才能发挥作用
- 验证工具可以自动检查代码是否符合规范
- 审查流程可以确保新代码符合规范

**替代方案**：
- 只创建规则文档（难以确保规则被执行）

### 决策6：更新现有代码以符合规范

**决策**：审查现有代码，修复不符合规范的问题。

**理由**：
- 现有代码可能不符合新规范
- 需要修复这些问题以确保一致性
- 可以作为新规范的示例

**替代方案**：
- 只创建新规范，不更新现有代码（可能导致不一致）

## Risks

### 风险1：规范过于严格

**风险**：规范过于严格可能导致开发效率降低。

**缓解措施**：
- 规范应该明确但不过于严格
- 提供清晰的示例和指导
- 允许在特殊情况下偏离规范（但需要记录原因）

### 风险2：现有代码不符合规范

**风险**：现有代码可能不符合新规范，需要大量修改。

**缓解措施**：
- 分阶段更新现有代码
- 优先更新关键代码
- 提供迁移指南

### 风险3：规范执行不力

**风险**：规范可能不被严格执行。

**缓解措施**：
- 创建规则验证工具（自动检查）
- 建立规则审查流程（人工审查）
- 在CI/CD中集成规则检查

## Migration Plan

### 阶段1：正式化规范文档（优先级：最高）

1. 审查现有的数据库设计规范草案
2. 补充完整的需求和场景定义
3. 确保规范覆盖所有关键设计决策
4. 更新规范文档状态为"正式"

### 阶段2：明确后端运作规则（优先级：高）

1. 定义数据入库流程规则
2. 定义字段映射规则与数据库设计规则的一致性要求
3. 定义事实表和物化视图的设计规则
4. 创建运营数据事实表（FactTraffic、FactService、FactAnalytics）
5. 更新相关规范文档

### 阶段3：建立规则执行机制（优先级：中）

1. 创建规则验证工具
2. 创建规则文档（供开发人员参考）
3. 建立规则审查流程
4. 在CI/CD中集成规则检查

### 阶段4：重构物化视图（优先级：中）

1. 创建数据域主视图（mv_product_management、mv_order_summary、mv_traffic_summary等）
2. 明确辅助视图的依赖关系
3. 更新物化视图刷新顺序
4. 更新前端查询逻辑（优先使用主视图）

### 阶段5：更新现有代码（优先级：中）

1. 审查现有代码是否符合新规范
2. 修复不符合规范的问题（主键设计、表结构等）
3. 更新文档以反映新规范

## Open Questions

- [ ] 规范应该多严格？是否允许特殊情况下的偏离？
- [ ] 规则验证工具应该检查哪些内容？
- [ ] 规则审查流程应该如何集成到开发流程中？
- [ ] 现有代码不符合规范时，应该如何处理？

