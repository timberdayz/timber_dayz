# 技术设计：建立前端API契约标准

## Context

当前系统中，后端API响应格式不统一，前端API调用分散在多个文件中，缺少统一的API契约规范。这导致：

1. **API响应格式不统一**：有些API返回`{"success": True, "data": {...}}`，有些直接返回数据对象
2. **错误处理格式不一致**：前端难以统一处理错误
3. **前端API调用分散**：API调用分散在多个文件中，难以维护
4. **缺少API契约文档**：新API开发时缺少参考标准

## Goals

- **统一API响应格式**：所有API使用统一的响应格式，便于前端统一处理
- **统一错误处理机制**：建立统一的错误码体系和错误处理流程
- **统一前端API调用规范**：建立统一的API调用方法和错误处理机制
- **建立API契约文档**：创建OpenSpec规范文档，指导API开发

## Non-Goals

- 不改变现有API接口的URL路径（保持向后兼容）
- 不改变现有API的业务逻辑（只统一响应格式）
- 不引入新的技术依赖（使用现有技术栈）
- 不强制要求立即重构所有现有API（渐进式迁移）

## Decisions

### 决策1：API响应格式标准

**决策**：采用统一的JSON响应格式，包含`success`、`data`、`message`、`timestamp`字段

**标准格式**：
```json
{
  "success": true,
  "data": {...},
  "message": "操作成功",
  "timestamp": "2025-01-16T10:30:00Z"
}
```

**错误格式**：
```json
{
  "success": false,
  "error": {
    "code": 2001,
    "type": "BusinessError",
    "detail": "..."
  },
  "message": "业务错误：...",
  "timestamp": "2025-01-16T10:30:00Z"
}
```

**理由**：
- 统一的响应格式便于前端统一处理
- `success`字段明确标识请求是否成功
- `data`字段包含实际数据
- `message`字段提供用户友好的提示信息
- `timestamp`字段便于调试和日志记录

**替代方案**：
- 直接返回数据对象（不便于统一错误处理）
- 使用HTTP状态码区分成功和失败（无法传递业务错误码）

### 决策2：错误码体系

**决策**：采用4位数字错误码，按错误类型分类

**错误码分类**：
- `1xxx`：系统错误（服务器错误、数据库错误等）
- `2xxx`：业务错误（业务逻辑错误、验证错误等）
- `3xxx`：数据错误（数据格式错误、数据缺失等）
- `4xxx`：用户错误（认证错误、权限错误等）

**理由**：
- 错误码分类清晰，便于定位问题
- 4位数字错误码便于扩展
- 与HTTP状态码配合使用，提供更详细的错误信息

**替代方案**：
- 使用字符串错误码（不便于排序和查找）
- 使用2位数字错误码（扩展性不足）

### 决策3：前端API调用规范

**决策**：采用统一的API调用方法命名规范（动词+名词），统一参数传递格式

**命名规范**：
- 查询：`getXxx`（如`getOrderList`、`getOrderDetail`）
- 创建：`createXxx`（如`createOrder`、`createProduct`）
- 更新：`updateXxx`（如`updateOrder`、`updateProduct`）
- 删除：`deleteXxx`（如`deleteOrder`、`deleteProduct`）

**参数传递**：
- 查询参数：使用`params`对象传递
- 请求体：使用`data`对象传递

**理由**：
- 统一的命名规范便于理解和维护
- RESTful风格的命名符合行业标准
- 统一的参数传递格式便于统一处理

**替代方案**：
- 使用不同的命名规范（不便于统一维护）
- 使用不同的参数传递格式（不便于统一处理）

### 决策4：一次性统一策略（无过渡期）

**决策**：由于系统处于开发阶段，未上线，采用一次性统一所有API的策略

**实施方式**：
1. **一次性统一所有API响应格式**：不保留过渡期，直接统一所有API
2. **同步更新前后端**：后端统一格式后，立即更新前端调用代码
3. **不添加兼容层**：直接按照统一标准实施，避免技术债务
4. **全面测试验证**：统一格式后进行全面测试，确保功能正常

**理由**：
- 系统未上线，没有现有用户，可以直接统一格式
- 避免技术债务，代码更清晰，维护更容易
- 一次性完成，避免后续迁移工作
- 统一标准，便于后续开发

**替代方案**：
- 渐进式迁移（不采用，因为系统未上线，无需过渡期）
- 保留兼容层（不采用，避免技术债务）

## Risks / Trade-offs

### 风险1：现有API响应格式不统一，迁移工作量大

**风险**：现有API响应格式不统一，需要逐个迁移，工作量大

**缓解措施**：
- 创建统一的响应格式工具函数，减少重复代码
- 采用渐进式迁移策略，优先迁移核心API
- 提供迁移指南和示例代码

### 风险2：前端代码需要同步更新，可能影响现有功能

**风险**：前端代码需要同步更新以适配新的响应格式，可能影响现有功能

**缓解措施**：
- 保持向后兼容，确保现有API仍然可用
- 逐步更新前端代码，确保每个模块都经过测试
- 提供回滚机制，确保可以快速回滚

### 风险3：错误处理机制不完善，可能遗漏某些错误场景

**风险**：错误处理机制可能不完善，可能遗漏某些错误场景

**缓解措施**：
- 建立完善的错误码体系，覆盖所有错误场景
- 提供错误处理示例和最佳实践
- 进行充分的测试，确保错误处理正确

## Migration Plan

### 当前状态

- ✅ 后端API已实现（FastAPI）
- ✅ 前端API调用已实现（Axios）
- ✅ 部分API已有统一响应格式（如`auto_ingest.py`）
- ❌ 缺少统一的API契约规范文档
- ❌ API响应格式不统一
- ❌ 前端API调用分散，缺少统一规范

### 迁移步骤（一次性完成，无过渡期）

1. **创建OpenSpec规范文档**
   - 创建`specs/frontend-api-contracts/spec.md`规范文档
   - 定义API响应格式、错误处理、数据格式等标准

2. **创建统一响应格式工具函数**
   - 创建`backend/utils/api_response.py`工具模块
   - 实现统一的响应格式函数

3. **更新全局异常处理**
   - 更新`backend/main.py`全局异常处理
   - 统一错误响应格式

4. **一次性统一所有API路由（无过渡期）**
   - **直接修改所有API路由**，统一响应格式
   - 不保留任何旧格式
   - 确保所有API都符合契约标准

5. **同步更新前端API调用规范**
   - **立即更新**`frontend/src/api/index.js`
   - **立即更新**所有模块化API文件
   - **不保留任何旧格式处理逻辑**

6. **全面测试和验证**
   - 测试所有API响应格式
   - 测试所有前端API调用
   - 端到端功能测试
   - **确保系统完全按照新标准运行**

### Rollback

- 本变更主要是格式统一，不涉及业务逻辑变更
- 如需回滚，可以恢复到之前的响应格式
- 建议在迁移前备份代码

### 决策5：数据分类传输规范

**决策**：建立A、B、C三类数据的API传输规范，明确各类数据的API端点和应用场景

**数据分类**：
- **A类数据（用户配置数据）**：
  - 数据来源：用户在系统中手动配置
  - API端点：`/api/sales-campaign/*`、`/api/target-management/*`、`/api/performance-management/*`
  - 应用场景：配置管理页面（创建/编辑/查看配置）
  - 特点：支持CRUD操作，实时更新，不需要Excel采集

- **B类数据（业务数据）**：
  - 数据来源：从Excel文件采集，通过字段映射系统入库
  - API端点：`/api/main-views/orders/*`、`/api/main-views/products/*`、`/api/inventory/*`、`/api/main-views/traffic/*`
  - 应用场景：业务概览、数据看板、数据浏览器页面
  - 特点：支持分页查询和筛选，数据量大，需要索引优化

- **C类数据（计算数据）**：
  - 数据来源：基于A类和B类数据计算得出
  - API端点：`/api/store-analytics/health-scores`、`/api/store-analytics/alerts`等
  - 应用场景：店铺管理、业务概览、销售分析页面
  - 特点：混合查询策略（物化视图 + 实时计算），支持标准时间维度和自定义时间范围

**理由**：
- 数据分类清晰，便于理解和管理
- 各类数据有不同的API端点和应用场景
- 便于前端选择合适的API获取数据
- 符合系统架构设计（三层数据分类）

**替代方案**：
- 不分类，统一API端点（不便于管理和优化）
- 按业务模块分类（不符合数据分类设计）

### 决策6：Mock数据替换策略

**决策**：采用渐进式替换策略，优先替换核心功能Mock数据，逐步替换其他功能Mock数据

**替换优先级**：
1. **优先级1：核心功能**（dashboard、business-overview）
   - 影响最大，用户最常使用
   - 需要尽快上线
2. **优先级2：业务功能**（store、sales、target）
   - 业务关键功能
   - 影响业务决策
3. **优先级3：辅助功能**（hr、inventory）
   - 辅助功能，影响较小
   - 可以稍后替换

**替换步骤**：
1. 梳理Mock数据使用情况
2. 识别对应的后端API
3. 替换Mock数据为真实API调用
4. 测试功能正常
5. 移除Mock数据开关和代码

**理由**：
- 渐进式替换降低风险
- 优先替换核心功能，确保核心功能可用
- 逐步替换其他功能，不影响现有功能

**替代方案**：
- 一次性替换所有Mock数据（风险高，工作量大）
- 不替换Mock数据（无法上线）

### 决策7：直接按标准实施策略（无过渡期）

**决策**：由于系统处于开发阶段，未上线，直接按照统一标准实施，不保留过渡期和兼容层

**实施方式**：
- **一次性统一所有API响应格式**：直接修改所有API，不保留旧格式
- **同步更新前后端**：后端统一格式后，立即更新前端调用代码
- **不添加兼容层**：直接按照统一标准实施，避免技术债务
- **全面测试验证**：统一格式后进行全面测试，确保功能正常

**理由**：
- 系统未上线，没有现有用户，可以直接统一格式
- 避免技术债务，代码更清晰，维护更容易
- 一次性完成，避免后续迁移工作
- 统一标准，便于后续开发

**替代方案**：
- 渐进式迁移（不采用，因为系统未上线，无需过渡期）
- 保留兼容层（不采用，避免技术债务）

### 决策8：性能优化策略

**决策**：采用缓存+批量查询+索引优化策略

**缓存策略**：
- C类数据缓存（健康度评分5分钟，达成率1分钟，排名5分钟）
- 支持缓存失效机制
- 监控缓存命中率

**批量查询优化**：
- 支持批量获取数据
- 减少API调用次数
- 优化数据传输量

**索引优化**：
- 添加数据库索引
- 优化SQL查询
- 使用物化视图

**理由**：
- 提升API响应速度
- 减少数据库负载
- 改善用户体验

**替代方案**：
- 不缓存（响应慢，用户体验差）
- 全量缓存（数据可能不实时）

### 决策11：C类数据查询策略（物化视图 + 实时计算混合模式）

**决策**：采用混合策略查询C类数据，优先使用物化视图，不满足时实时计算，避免物化视图过大问题

**查询策略**：
1. **标准时间维度查询**（daily/weekly/monthly）且在物化视图范围内（90天内）
   - 从物化视图查询（`mv_shop_health_summary`、`mv_shop_daily_performance`等）
   - 响应时间<100ms
   - 物化视图预计算，查询性能高

2. **自定义时间范围查询**或超出物化视图范围（>90天）
   - 从fact表实时计算（调用`ShopHealthService.calculate_health_score()`等）
   - 响应时间<2s
   - 支持任意时间范围，计算结果准确

3. **智能路由**（多维度判断矩阵）
   - **判断维度**：
     - 时间维度：标准粒度（daily/weekly/monthly）vs 自定义时间范围
     - 时间范围：是否在物化视图范围内（2年内）
     - 店铺维度：单店铺 vs 多店铺（≤10个）vs 全部店铺
     - 账号维度：单账号 vs 多账号（≤5个）vs 全部账号
     - 平台维度：单平台 vs 多平台（≤3个）vs 全部平台
   - **路由规则**：
     - ✅ **使用物化视图**（<100ms）：标准粒度 + 2年内 + 单店铺/≤10店铺 + 单账号/≤5账号 + 单平台/≤3平台
     - ⚠️ **使用实时计算**（<2s）：自定义时间范围 OR 超出2年 OR >10店铺 OR >5账号 OR >3平台 OR 跨维度查询
   - 前端统一API接口，无需关心查询方式

**物化视图存储策略（分层存储架构）**：
- **热数据层（物化视图）**：
  - 保留时间：**2年（730天）**，支持年度对比和月度对比
  - 存储粒度：daily粒度（weekly/monthly从daily聚合计算）
  - 用途：快速查询最近2年的数据
  - 性能：<100ms
- **温数据层（fact表 + 索引优化）**：
  - 保留时间：2-5年
  - 存储粒度：daily粒度（原始数据）
  - 用途：查询2-5年的历史数据
  - 性能：<2s（索引优化）
- **冷数据层（归档表）**：
  - 保留时间：5年以上
  - 存储粒度：monthly粒度（聚合归档）
  - 用途：长期趋势分析、多年对比
  - 性能：<5s（归档查询）
- **定期清理**：自动清理过期数据，保持物化视图大小可控

**理由**：
- 物化视图提升标准查询性能（<100ms）
- 实时计算支持灵活查询（自定义时间范围）
- 混合策略平衡性能和灵活性
- 避免物化视图过大问题（只存储daily粒度，不存储所有组合）

**替代方案**：
- 全部实时计算（性能差，响应慢）
- 全部物化视图（存储爆炸，无法支持自定义时间范围）
- 存储所有粒度组合（weekly/monthly单独存储，存储空间爆炸）
- 只保留90天数据（无法支持年度对比和多年数据对比）

### 决策12：错误码体系（企业级ERP标准）

**决策**：采用4位数字错误码，按模块细分，参考SAP/Oracle ERP标准

**错误码分类**：
- **1xxx - 系统错误**（基础设施层）：
  - 1001-1099：数据库错误
  - 1100-1199：缓存错误
  - 1200-1299：消息队列错误
  - 1300-1399：文件系统错误
  - 1400-1499：网络错误
- **2xxx - 业务错误**（业务逻辑层）：
  - 2001-2099：订单业务错误
  - 2100-2199：库存业务错误
  - 2200-2299：财务业务错误
  - 2300-2399：销售业务错误
  - 2400-2499：数据同步错误
- **3xxx - 数据错误**（数据层）：
  - 3001-3099：数据验证错误
  - 3100-3199：数据格式错误
  - 3200-3299：数据完整性错误
  - 3300-3399：数据隔离错误
- **4xxx - 用户错误**（用户层）：
  - 4001-4099：认证错误
  - 4100-4199：权限错误
  - 4200-4299：参数错误
  - 4300-4399：请求频率限制

**理由**：
- 错误码分类清晰，便于定位问题
- 按模块细分，便于扩展和维护
- 4位数字错误码，支持1000个错误码/模块
- 符合企业级ERP标准（SAP/Oracle）

**替代方案**：
- 使用字符串错误码（不便于排序和查找）
- 使用2位数字错误码（扩展性不足）
- 不按模块细分（难以管理和扩展）

### 决策13：分页响应格式

**决策**：分页响应包含完整分页信息，便于前端分页组件使用

**标准格式**：
```json
{
  "success": true,
  "data": [...],
  "pagination": {
    "page": 1,
    "page_size": 20,
    "total": 100,
    "total_pages": 5,
    "has_previous": false,
    "has_next": true
  },
  "timestamp": "2025-01-16T10:30:00Z"
}
```

**理由**：
- `total_pages`便于前端计算总页数
- `has_previous`和`has_next`便于前端控制翻页按钮
- 完整的分页信息，前端无需额外计算

**替代方案**：
- 不包含`total_pages`（前端需要计算）
- 不包含`has_previous`和`has_next`（前端需要判断）

### 决策14：API版本控制

**决策**：采用URL路径版本控制，支持向后兼容

**版本控制策略**：
- **当前阶段（v1.0）**：保持现有API路径`/api/xxx`（不立即实施版本控制）
  - 原因：系统未上线，无需版本控制
  - 所有API保持`/api/xxx`路径
- **未来阶段（v2.0+）**：新API使用`/api/v2/xxx`路径
  - 新功能、破坏性变更使用v2版本
  - 旧API保持`/api/xxx`路径（向后兼容）
- **向后兼容**：至少支持2个主要版本同时运行
- **弃用策略**：
  - 提前3个月通知API弃用
  - 1年后移除旧版本API
  - 提供迁移指南和工具

**理由**：
- 当前阶段无需版本控制（系统未上线）
- 未来阶段支持多版本同时运行，便于平滑迁移
- URL路径版本控制简单直观
- 符合RESTful API设计最佳实践

**替代方案**：
- 立即实施版本控制（不必要，系统未上线）
- Header版本控制（不够直观）
- 查询参数版本控制（不够RESTful）
- 不版本控制（未来无法处理破坏性变更）

### 决策15：性能监控

**决策**：分阶段建立关键性能指标监控体系

**当前阶段（v1.0）**：基础监控（日志记录）
- **监控指标**：
  - API响应时间（日志记录）
  - 错误率（日志记录）
  - 慢查询（PostgreSQL慢查询日志）
- **监控工具**：
  - 应用日志（Python logging）
  - 数据库慢查询日志
- **实施方式**：
  - 在API响应拦截器中记录响应时间
  - 在错误处理中记录错误日志
  - 启用PostgreSQL慢查询日志（>100ms）

**未来阶段（v2.0+）**：完整监控体系
- **监控指标**：
  1. **API响应时间**：P50/P95/P99分位数
  2. **错误率**：4xx/5xx错误率
  3. **缓存命中率**：物化视图查询率、Redis缓存命中率
  4. **数据库查询时间**：慢查询监控（>100ms）
  5. **并发请求数**：QPS（每秒查询数）
- **监控工具**：
  - 应用层监控：Prometheus + Grafana
  - 日志监控：ELK Stack（Elasticsearch + Logstash + Kibana）
  - 数据库监控：PostgreSQL慢查询日志

**理由**：
- 当前阶段基础监控足够（系统未上线，数据量小）
- 未来阶段完整监控体系（系统上线后，数据量大，需要实时监控）
- 分阶段实施降低复杂度
- 符合企业级ERP运维标准

**替代方案**：
- 立即实施完整监控体系（不必要，系统未上线）
- 不监控（无法发现性能问题）

## Risks / Trade-offs

### 风险4：API端点不存在导致Mock数据替换失败

**风险**：部分Mock数据替换时提到的API端点可能不存在

**缓解措施**：
- 先确认所有API端点是否存在
- 不存在则创建或使用替代方案
- 提供API端点清单文档

### 风险5：统一响应格式需要同步更新前后端

**风险**：统一响应格式需要同步更新前后端代码

**缓解措施**：
- **一次性统一所有API响应格式**：直接修改所有API，不保留旧格式
- **同步更新前后端**：后端统一格式后，立即更新前端调用代码
- **充分测试**：统一格式后进行全面测试，确保功能正常
- **代码审查**：确保前后端格式一致

### 风险6：C类数据实时计算影响性能

**风险**：C类数据实时计算可能影响API响应时间

**缓解措施**：
- 实现缓存策略，减少计算次数
- 优化计算算法，提升计算速度
- 使用物化视图，预计算数据

### 风险7：物化视图过大问题

**风险**：C类数据如果全部从物化视图查询，会导致物化视图过大问题
- 前端需要支持日/周/月时间维度切换
- 前端需要支持自定义时间范围
- 业务需要支持多年数据对比（环比去年、前年、若干年）
- 如果存储所有粒度组合，会导致存储爆炸

**缓解措施**：
- 采用分层存储策略（热数据2年 + 温数据2-5年 + 冷数据5年以上）
- 物化视图只存储daily粒度，weekly/monthly从daily聚合计算
- 智能路由：多维度判断（时间/店铺/账号/平台），自动选择最优查询方式
- 标准时间维度优先使用物化视图，自定义时间范围或超出范围实时计算

### 风险8：数据流转流程自动化程度

**风险**：数据流转流程如果不够自动化，会影响系统效率和用户体验

**缓解措施**：
- **B类数据入库后**：自动触发物化视图刷新（Celery异步任务）
- **物化视图刷新后**：自动计算C类数据（Celery异步任务）
- **A类数据更新后**：自动触发相关C类数据重新计算
- **前端更新**：WebSocket推送或轮询机制（可选）
- 事件驱动架构，确保数据流转高效自动化

## Open Questions

- [x] ~~错误码体系是否需要更细的分类？~~（已决定：按模块细分，企业级ERP标准）
- [x] ~~分页响应格式是否需要包含更多信息（如总页数）？~~（已决定：包含total_pages、has_previous、has_next）
- [x] ~~是否需要支持API版本控制？~~（已决定：URL路径版本控制，支持向后兼容，**当前阶段保持/api/xxx，未来新API使用/api/v2/xxx**）
- [ ] 是否需要支持批量操作API的特殊响应格式？
- [ ] C类数据的实时计算频率如何设置？（实时/每分钟/每小时）
- [ ] C类数据的缓存策略如何设计？（缓存时间、缓存失效机制）
- [ ] 哪些C类数据API需要新增？（达成率计算、排名数据等）
- [x] ~~兼容层需要保留多长时间？~~（已决定：不添加兼容层，直接按标准实施）
- [x] ~~如何监控API性能？~~（已决定：**当前阶段基础监控（日志记录），未来阶段完整监控体系（Prometheus + Grafana）**）
- [x] ~~物化视图保留时间如何设置？~~（已决定：2年（730天），支持年度对比）
- [x] ~~C类数据查询策略的智能路由阈值如何设置？~~（已决定：多维度判断矩阵，≤10店铺/≤5账号/≤3平台使用物化视图）
- [x] ~~前端空数据处理策略如何设计？~~（已决定：统一处理空数据，显示"-"或"0"，不抛出错误）

### 决策16：前端空数据处理策略（开发阶段容错）

**决策**：前端统一处理空数据，显示"-"或"0"，不抛出错误

**重要区分：空数据 vs API错误**
- **空数据**：API成功返回（`success: true`），但数据为空 → 显示"-"
- **API错误**：API返回错误（`success: false`）或请求失败 → 显示错误信息

**空数据处理规则**（仅适用于API成功时）：
- **数值类型**（金额、数量、百分比）：显示"-"
- **字符串类型**（名称、描述）：显示"-"
- **日期时间类型**：显示"-"
- **列表类型**：显示空状态提示（"暂无数据"）
- **对象类型**：使用默认值对象（{}），安全访问属性

**API错误处理规则**：
- **API路径错误**（404）：显示"API路径不存在：/api/xxx"
- **网络错误**：显示"网络连接失败，请检查网络"
- **服务器错误**（500）：显示"服务器错误：xxx"
- **业务错误**（success: false）：显示错误码和错误消息

**实现方式**：
- **API响应拦截器**（`frontend/src/api/index.js`）：
  - 首先判断`success`字段
  - `success: true` → 提取`data`字段返回给调用方（组件收到的是`data`内容）
  - `success: false` → 提取`error`字段，抛出错误（组件通过catch捕获）
  - 网络错误/404/500 → 抛出错误（组件通过catch捕获）
- **组件层**：
  - API成功时：收到`data`字段内容，使用格式化函数处理空数据（显示"-"）
  - API错误时：通过catch捕获错误，使用错误处理函数显示错误信息（不显示"-"）
- **工具函数**：
  - 创建统一的数据格式化工具函数（仅处理空数据，不处理错误）
  - 创建统一的错误处理工具函数（处理API错误）
- **安全访问**：
  - 使用Vue计算属性安全访问数据
  - 使用可选链操作符（`?.`）访问对象属性
  - 表格组件使用`empty-text`属性（仅API成功时）

**理由**：
- 开发阶段需要频繁重新入库数据，前端容错性很重要
- 便于观察数据变化（从"-"变为实际值）
- **避免误导开发者**：API错误时显示错误信息，不显示"-"
- 提升用户体验（生产环境也需要容错）
- 符合企业级ERP系统容错标准

**替代方案**：
- 不区分空数据和错误（会误导开发者，API错误时也显示"-"）
- 空数据也显示错误信息（不友好，影响数据审查）
- 使用占位符文本（不够统一，维护困难）

### 风险9：前端空数据处理缺失

**风险**：开发阶段频繁重新入库数据，前端在数据缺失时可能报错，影响数据变化观察和开发效率

**缓解措施**：
- 创建统一的数据格式化工具函数（仅处理空数据）
- 创建统一的错误处理工具函数（处理API错误）
- API响应拦截器首先判断`success`字段，区分空数据和错误
- 前端统一处理空数据，显示"-"或"0"（仅API成功时）
- 前端统一处理API错误，显示错误信息（避免误导开发者）
- 使用可选链操作符安全访问对象属性
- 记录空数据日志和错误日志（开发环境）

