# Change: 执行器统一管理和资源优化

## Why

当前系统在执行器和资源管理方面存在以下问题：

1. **执行器分散管理**：进程池和线程池分散在多个文件中，没有统一的生命周期管理

   - `raw_data_importer.py` 中定义了 `ThreadPoolExecutor(max_workers=10)`
   - `data_sync_service.py` 和 `data_ingestion_service.py` 中使用 `run_in_executor(None, ...)`（默认线程池）
   - 缺少统一的执行器管理器

2. **资源浪费**：开发环境和生产环境使用相同的资源配置

   - 开发环境不需要大量进程/线程，造成资源浪费
   - 生产环境无法根据服务器配置自动优化

3. **缺少资源监控**：无法实时了解资源使用情况

   - 无法监控进程池/线程池的使用率
   - 无法及时发现资源瓶颈
   - 无法为扩容决策提供数据支持

4. **CPU 密集型操作阻塞**：Excel 读取等 CPU 密集型操作在线程池中执行，仍可能影响事件循环

   - 当前使用 `run_in_executor(None, ...)` 使用默认线程池
   - 多个文件同时同步时，CPU 被占满，事件循环变慢
   - 需要将 CPU 密集型操作迁移到进程池（完全隔离）

5. **不符合现代化架构标准**：缺少统一的资源管理，不符合现代化 Web 架构的最佳实践
   - 现代化架构要求统一的执行器管理器
   - 环境感知的资源配置
   - 资源使用率监控

**问题影响**：

- 开发环境资源浪费（30-50%）
- 生产环境无法根据负载自动优化
- 无法及时发现资源瓶颈
- CPU 密集型操作可能阻塞事件循环

## What Changes

### Phase 1: 创建执行器管理器（P0 - 必须）

- [ ] **创建 ExecutorManager**：统一管理进程池和线程池

  - 单例模式，避免重复创建
  - 根据环境（开发/生产）动态调整配置
  - 支持优雅关闭
  - 进程池大小：`max(1, CPU核心数 - 1)`（业界常用做法，为主进程预留 1 核）
  - 线程池大小：`min(CPU核心数 * 5, 20)`（I/O 密集型操作）

- [ ] **环境感知的资源配置**：

  - 开发环境：也使用 `max(1, CPU核心数 - 1)`（充分利用开发电脑性能）
  - 生产环境：根据服务器配置自动优化
  - 支持通过环境变量覆盖默认配置
  - Docker 容器支持：自动检测容器 CPU 限制（如果设置了）

- [ ] **执行器生命周期管理**：
  - 在 `backend/main.py` 的 `lifespan` 函数中初始化
  - 应用关闭时优雅关闭所有执行器

### Phase 2: CPU 密集型操作迁移到进程池（P0 - 必须）

- [ ] **Excel 读取迁移到进程池**：

  - 修改 `data_sync_service.py` 中的 Excel 读取操作
  - 修改 `data_ingestion_service.py` 中的 Excel 读取操作
  - 使用 `ExecutorManager.run_cpu_intensive()` 替代 `run_in_executor(None, ...)`

- [ ] **其他 CPU 密集型操作识别和迁移**：
  - 识别其他 CPU 密集型操作（图片处理、数据计算等）
  - 迁移到进程池

### Phase 3: 资源监控接口（P1 - 重要）

- [ ] **创建资源监控 API**：

  - `/api/system/resource-usage`：获取当前资源使用情况
  - `/api/system/executor-stats`：获取执行器统计信息
  - `/api/system/db-pool-stats`：获取数据库连接池统计

- [ ] **监控指标**：
  - CPU 使用率
  - 内存使用率
  - 进程池活跃任务数
  - 线程池活跃任务数
  - 数据库连接池使用率

### Phase 4: 数据库连接池动态调整（P1 - 重要）

- [ ] **根据服务器配置动态调整**：
  - 同步引擎：使用 `settings.DB_POOL_SIZE` 和 `settings.DB_MAX_OVERFLOW`（已支持环境变量）
  - 异步引擎：当前硬编码为 `pool_size=30, max_overflow=20`，需要改为使用环境变量或动态计算
  - 基础连接数：`min(30, CPU核心数 * 10)`
  - 溢出连接数：`min(20, CPU核心数 * 5)`
  - 开发环境：固定较小值（10 基础 + 10 溢出）

### Phase 5: 资源告警机制（P2 - 可选）

- [ ] **创建资源监控服务**：
  - 定期检查资源使用率
  - 当资源使用率超过阈值时记录警告日志
  - 可选：发送告警通知（邮件/短信/Webhook）

## Impact

### 受影响的代码位置

| 类型         | 文件数    | 修改点数 | 优先级 |
| ------------ | --------- | -------- | ------ |
| 执行器管理器 | 1（新建） | 100+     | P0     |
| 数据同步服务 | 2         | 10+      | P0     |
| 数据入库服务 | 1         | 5+       | P0     |
| 资源监控 API | 1（新建） | 50+      | P1     |
| 数据库配置   | 1         | 10+      | P1     |
| 主应用启动   | 1         | 5+       | P0     |

### 性能预期

| 指标                         | 当前               | 优化后             | 提升幅度     |
| ---------------------------- | ------------------ | ------------------ | ------------ |
| 开发环境内存消耗             | 1.4GB              | 0.7-1.0GB          | ⬇️ 30-50%    |
| 生产环境资源利用率           | 固定配置           | 自动优化           | ⬆️ 20-30%    |
| CPU 密集型操作隔离           | 线程池（部分隔离） | 进程池（完全隔离） | ⬆️ 100%      |
| 事件循环响应时间（同步期间） | 可能变慢           | <100ms             | ⬆️ 10-100 倍 |
| 资源监控能力                 | 无                 | 实时监控           | ⬆️ 100%      |

**进程池配置说明**（采用业界常用做法：CPU 核心数 - 1）：

- 16 核服务器：使用 15 个进程（为主进程预留 1 核）
- 8 核服务器：使用 7 个进程（为主进程预留 1 核）
- 4 核服务器：使用 3 个进程（为主进程预留 1 核）
- 2 核服务器：使用 1 个进程（为主进程预留 1 核）
- 开发环境：也使用 `max(1, CPU核心数 - 1)`（充分利用开发电脑性能）
- Docker 容器：如果设置了 CPU 限制（如 `cpus: '2'`），将使用限制值计算（2-1=1 个进程）

### 成本优化

**小型部署（10-50 用户）**：

- 当前：¥200-300/月
- 优化后：¥150-250/月（可能降低 10-20%）

**中型部署（50-200 用户）**：

- 当前：¥400-900/月
- 优化后：¥350-800/月（可能降低 5-10%）

**大型部署（200+用户）**：

- 当前：¥1300-2000/月
- 优化后：通过监控和告警，避免不必要的扩容

### 架构改进

**现代化架构符合度**：

- 当前：约 75%
- 优化后：约 85-90%

**改进点**：

- ✅ 统一的执行器管理器
- ✅ 环境感知的资源配置
- ✅ 资源使用率监控
- ✅ CPU 密集型操作完全隔离

### 风险评估

| 风险                 | 严重程度 | 缓解措施                                                   |
| -------------------- | -------- | ---------------------------------------------------------- |
| 进程池序列化问题     | 中       | 确保 ExcelParser.read_excel 可序列化（pickle）             |
| 资源监控性能开销     | 低       | 使用轻量级监控，避免频繁查询                               |
| 配置错误导致资源耗尽 | 低       | 使用业界标准公式（CPU 核心数-1），添加配置验证和默认值保护 |
| 执行器关闭时任务丢失 | 低       | 优雅关闭，等待任务完成                                     |

### Docker 容器化支持

**当前状态**：

- ✅ PostgreSQL 已在 Docker 中运行（docker-compose.yml）
- ✅ Metabase 已在 Docker 中运行
- ✅ 后端应用支持 Docker 容器化（已有 Dockerfile 和 docker-compose 配置）
- ✅ 前端应用支持 Docker 容器化（已有 Dockerfile 和 docker-compose 配置）

**注意事项**：

- Docker 容器中的 `os.cpu_count()` 可能返回主机 CPU 核心数
- 如果容器设置了 CPU 限制（如 `cpus: '2'`），建议通过环境变量 `CPU_EXECUTOR_WORKERS` 手动设置
- 当前 docker-compose.yml 中后端容器限制为 2 CPU，进程池将使用 1 个进程（2-1=1）
- 未来可优化：从 Docker cgroup 读取实际 CPU 限制（可选，P2）

### 兼容性

- ✅ **向后兼容**：保留现有 API 接口，不影响前端
- ✅ **渐进式迁移**：可以分阶段实施，不影响现有功能
- ✅ **配置可选**：所有新配置都有合理的默认值

### 依赖变更

**已有依赖**（无需新增）：

- ✅ `psutil>=5.9.0`（已在 requirements.txt 中，用于资源监控）

**无需新增依赖**：

- ✅ `concurrent.futures.ProcessPoolExecutor`（Python 标准库）
- ✅ `concurrent.futures.ThreadPoolExecutor`（Python 标准库）

### 测试要求

- [ ] 单元测试：ExecutorManager 的功能测试
- [ ] 集成测试：数据同步在进程池中执行的测试
- [ ] 性能测试：验证事件循环响应时间
- [ ] 资源监控测试：验证监控接口正常工作
- [ ] 压力测试：验证多人并发场景下的资源使用
- [ ] Docker 容器测试：验证容器内资源检测和配置
