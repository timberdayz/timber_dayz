# 漏洞分析报告：伪异步架构问题

## 概述

经过对代码库的全面审计，发现当前系统存在**伪异步架构**问题，即使用 `async def` 定义函数，但内部调用同步数据库操作，导致事件循环阻塞。

## 漏洞详情

### 漏洞 1：async def 中使用同步 db.query()

**严重程度**: 🔴 高

**发现位置**: 27 个文件，包括：
- `backend/routers/data_sync.py`
- `backend/routers/collection.py`
- `backend/services/data_sync_service.py`
- `backend/routers/field_mapping.py`
- 等 23 个其他文件

**问题代码示例**:
```python
# backend/services/data_sync_service.py:150-174
async def sync_single_file(self, file_id: int, ...):
    # ❌ 同步查询在 async def 中，阻塞事件循环
    catalog_file = self.db.query(CatalogFile).filter(
        CatalogFile.id == file_id
    ).first()
```

**影响**:
- 事件循环被阻塞
- 其他 API 请求无法处理
- 前端显示"转圈"无响应

**修复方案**:
```python
async def sync_single_file(self, file_id: int, ...):
    # ✅ 异步查询，不阻塞事件循环
    result = await self.db.execute(
        select(CatalogFile).where(CatalogFile.id == file_id)
    )
    catalog_file = result.scalar_one_or_none()
```

---

### 漏洞 2：后台任务使用同步 SessionLocal()

**严重程度**: 🔴 高

**发现位置**: 21 处，主要在：
- `backend/routers/data_sync.py:392, 407, 514`
- `backend/tasks/scheduled_tasks.py:263`
- `backend/routers/collection.py:1047`

**问题代码示例**:
```python
# backend/routers/data_sync.py:512-516
async def sync_file_with_semaphore(file_id: int):
    async with semaphore:
        db = SessionLocal()  # ❌ 同步会话
        try:
            sync_service = DataSyncService(db)
            result = await sync_service.sync_single_file(...)  # 内部仍是同步
```

**影响**:
- 即使使用 `asyncio.Semaphore` 控制并发，底层仍是同步阻塞
- 多个协程争抢事件循环时间

**修复方案**:
```python
async def sync_file_with_semaphore(file_id: int):
    async with semaphore:
        async with AsyncSessionLocal() as db:  # ✅ 异步会话
            sync_service = DataSyncService(db)
            result = await sync_service.sync_single_file(...)
```

---

### 漏洞 3：time.sleep() 阻塞调用

**严重程度**: 🟡 中

**发现位置**: 10 处，主要在：
- `backend/services/sync_progress_tracker.py:211` (重试逻辑)
- `backend/tests/stability_test.py:210, 214`
- `backend/services/performance_monitor.py:165, 168`

**问题代码示例**:
```python
# backend/services/sync_progress_tracker.py:210-211
import time
time.sleep(0.1 * retry_count)  # ❌ 阻塞事件循环
```

**影响**:
- 重试期间阻塞事件循环
- 其他请求被延迟

**修复方案**:
```python
import asyncio
await asyncio.sleep(0.1 * retry_count)  # ✅ 非阻塞等待
```

---

### 漏洞 4：db.execute() 未 await

**严重程度**: 🟡 中

**发现位置**: 26 个文件使用 `.execute()` 但部分场景可能缺少 `await`

**需要验证的文件**:
- `backend/routers/data_sync.py`
- `backend/routers/auto_ingest.py`
- `backend/routers/collection.py`
- 等

**注意**: 当前使用的是同步 `Session.execute()`，迁移到异步后需要确保所有 `execute()` 都有 `await`。

---

### 漏洞 5：采集任务后台函数混合同步/异步

**严重程度**: 🔴 高

**发现位置**: `backend/routers/collection.py:1013-1086`

**问题代码示例**:
```python
# backend/routers/collection.py:1046-1059
async def _execute_collection_task_background(...):
    SessionLocal = sessionmaker(bind=db_session_maker)
    db = SessionLocal()  # ❌ 同步会话
    
    try:
        task = db.query(CollectionTask).filter(...).first()  # ❌ 同步查询
        task.status = "running"
        db.commit()  # ❌ 同步提交
```

**影响**:
- 采集任务执行期间，其他 API 请求被阻塞
- 多个采集任务同时执行时，阻塞更严重

---

### 漏洞 6：定时任务使用同步数据库操作

**严重程度**: 🟡 中

**发现位置**: `backend/tasks/scheduled_tasks.py`

**问题代码示例**:
```python
# backend/tasks/scheduled_tasks.py:72-100
def refresh_inventory_finance_views():
    db = SessionLocal()
    try:
        # 同步数据库操作
        db.query(...).all()
        db.commit()
    finally:
        db.close()
```

**影响**:
- Celery 任务执行期间占用数据库连接
- 不影响 FastAPI 事件循环（独立进程），但影响连接池

---

## 统计汇总

| 漏洞类型 | 发现数量 | 严重程度 | 优先级 |
|---------|---------|---------|--------|
| async def + 同步 db.query() | 27 个文件 | 🔴 高 | P0 |
| 后台任务同步 SessionLocal | 21 处 | 🔴 高 | P0 |
| time.sleep() 阻塞 | 10 处 | 🟡 中 | P1 |
| db.execute() 缺 await 风险 | 26 个文件 | 🟡 中 | P1 |
| 采集任务混合模式 | 1 个函数 | 🔴 高 | P0 |
| 定时任务同步操作 | 3 个函数 | 🟡 中 | P2 |

## 修复优先级

### P0（必须立即修复）
1. `backend/services/data_sync_service.py` - DataSyncService 异步化
2. `backend/routers/data_sync.py` - 后台任务函数异步化
3. `backend/routers/collection.py` - 采集后台任务异步化

### P1（尽快修复）
1. `backend/services/sync_progress_tracker.py` - 移除 time.sleep()
2. 其他高频路由模块（field_mapping, auto_ingest 等）

### P2（计划修复）
1. 定时任务模块（独立进程，影响较小）
2. 低频路由模块

## 验证方法

### 1. 检测同步调用遗漏
```bash
# 检测 async def 中的 db.query() 调用
grep -rn "async def" backend/ | grep -v "__pycache__" | \
    while read line; do 
        file=$(echo $line | cut -d: -f1)
        grep -l "db.query\|\.query(" $file 2>/dev/null
    done | sort -u
```

### 2. 检测 time.sleep() 使用
```bash
grep -rn "time\.sleep\(" backend/ --include="*.py" | grep -v "__pycache__"
```

### 3. 检测 SessionLocal() 直接使用
```bash
grep -rn "SessionLocal()" backend/ --include="*.py" | grep -v "__pycache__"
```

## 结论

当前系统存在严重的**伪异步架构**问题，需要迁移到真正的异步 SQLAlchemy 模式。迁移工作量较大（100+ 个文件，2000+ 行代码），但对系统稳定性和用户体验至关重要。

建议按照 `proposal.md` 中的分阶段迁移计划进行，优先解决数据同步模块（影响最大）。

